import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a,b as e,o as t}from"./app-jl_0F-Zm.js";const i="/image/cloud/cloud21.png",p="/image/cloud/cloud22.png",o="/image/cloud/cloud23.png",l="/image/cloud/cloud24.png",c="/image/cloud/cloud25.png",u="/image/cloud/cloud26.png",r="/image/cloud/cloud27.png",d="/image/cloud/cloud28.png",m="/image/cloud/cloud29.png",k="/image/cloud/cloud30.png",g="/image/cloud/cloud31.png",v="/image/cloud/cloud32.png",b="/image/cloud/cloud33.png",h="/image/cloud/cloud34.png",f={},y=e('<h1 id="mq基础" tabindex="-1"><a class="header-anchor" href="#mq基础"><span>MQ基础</span></a></h1><h2 id="一、异步通讯" tabindex="-1"><a class="header-anchor" href="#一、异步通讯"><span>一、异步通讯</span></a></h2><p>目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要<strong>等待</strong>服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为<strong>同步调用</strong>，也可以叫<strong>同步通讯</strong>。但在很多场景下，我们可能需要采用<strong>异步通讯</strong>的方式，为什么呢？</p><p>我们先来看看什么是同步通讯和异步通讯。如图：</p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container tip"><p class="hint-container-title">解读</p><ul><li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li><li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li></ul></div><p>如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。</p><h2 id="二、mq" tabindex="-1"><a class="header-anchor" href="#二、mq"><span>二、MQ</span></a></h2><h3 id="_1、同步调用" tabindex="-1"><a class="header-anchor" href="#_1、同步调用"><span>1、同步调用</span></a></h3><p>之前说过，我们现在基于OpenFeign的调用都属于是同步调用，那么这种方式存在哪些问题呢？</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>目前我们采用的是基于OpenFeign的同步调用，也就是说业务执行流程是这样的：</p><ul><li>支付服务需要先调用用户服务完成余额扣减</li><li>然后支付服务自己要更新支付流水单的状态</li><li>然后支付服务调用交易服务，更新业务订单状态为已支付</li></ul><p>三个步骤依次执行。</p><div class="hint-container info"><p class="hint-container-title">问题</p><ul><li><strong>拓展性差</strong> 每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动，不符合开闭原则，拓展性不好。</li><li><strong>性能下降</strong> 最终整个业务的响应时长就是每次远程调用的执行时长之和</li><li><strong>级联失败</strong> 由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。</li></ul></div><p>而要解决这些问题，我们就必须用<strong>异步调用</strong>的方式来代替<strong>同步调用</strong>。</p><h3 id="_2、异步调用" tabindex="-1"><a class="header-anchor" href="#_2、异步调用"><span>2、异步调用</span></a></h3><p>异步调用方式其实就是基于消息通知的方式</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><ul><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ul></div><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。这样，发送消息的人和接收消息的人就完全解耦了。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。</p><p>假如产品经理提出了新的需求，比如要在支付成功后更新用户积分。支付代码完全不用变更，而仅仅是让积分服务也订阅消息即可：</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container tip"><p class="hint-container-title">异步调用的优势包括：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li></ul></div><div class="hint-container warning"><p class="hint-container-title">缺点：</p><ul><li>完全依赖于Broker的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul></div><h2 id="三、技术选型" tabindex="-1"><a class="header-anchor" href="#三、技术选型"><span>三、技术选型</span></a></h2><h3 id="_1、常见mq介绍" tabindex="-1"><a class="header-anchor" href="#_1、常见mq介绍"><span>1、常见MQ介绍</span></a></h3><p>消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ.</p><div class="hint-container info"><p class="hint-container-title">目比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul></div><p>几种常见MQ的对比：</p><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container tip"><p class="hint-container-title">提示</p><ul><li><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p></li><li><p>追求可靠性：RabbitMQ、RocketMQ</p></li><li><p>追求吞吐能力：RocketMQ、Kafka</p></li><li><p>追求消息低延迟：RabbitMQ、Kafka</p></li></ul></div><p>据统计，目前国内消息队列使用最多的还是RabbitMQ，再加上其各方面都比较均衡，稳定性也好。</p><h3 id="_2、rabbitmq" tabindex="-1"><a class="header-anchor" href="#_2、rabbitmq"><span>2、RabbitMQ</span></a></h3><p>我们同样基于Docker来安装RabbitMQ，使用下面的命令即可：</p><div class="language-Shell line-numbers-mode" data-ext="Shell" data-title="Shell"><pre class="language-Shell"><code>docker run \\
 -e RABBITMQ_DEFAULT_USER=ruyi \\
 -e RABBITMQ_DEFAULT_PASS=123321 \\
 -v mq-plugins:/plugins \\
 --name mq \\
 --hostname mq \\
 -p 15672:15672 \\
 -p 5672:5672 \\
 --network hm-net\\
 -d \\
 rabbitmq:3.8-management
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到在安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>RabbitMQ对应的架构如图：</p><figure><img src="`+r+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container tip"><p class="hint-container-title">其中包含几个概念：</p><ul><li><strong><code>publisher</code></strong>：生产者，也就是发送消息的一方</li><li><strong><code>consumer</code></strong>：消费者，也就是消费消息的一方</li><li><strong><code>queue</code></strong>：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li><strong><code>exchange</code></strong>：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li><strong><code>virtual host</code></strong>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul></div><p><strong>上述这些东西都可以在RabbitMQ的管理控制台来管理</strong></p><h2 id="四、springamqp" tabindex="-1"><a class="header-anchor" href="#四、springamqp"><span>四、SpringAMQP</span></a></h2><h3 id="_1、介绍" tabindex="-1"><a class="header-anchor" href="#_1、介绍"><span>1、介绍</span></a></h3><p>由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互。并且<code>RabbitMQ</code>官方也提供了各种不同语言的客户端。</p><p>Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配。<a href="https://spring.io/projects/spring-amqp" target="_blank" rel="noopener noreferrer">官方地址</a></p><div class="hint-container info"><p class="hint-container-title">SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul></div><h3 id="_2、使用" tabindex="-1"><a class="header-anchor" href="#_2、使用"><span>2、使用</span></a></h3><p><strong>1）导入依赖</strong></p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code> 		<span class="token comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2）消息发送</strong></p><p>首先配置MQ地址，在<code>publisher</code>服务的<code>application.yml</code>中添加配置：</p><div class="language-yaml line-numbers-mode" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.175.129 <span class="token comment"># 你的虚拟机IP</span>
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span> <span class="token comment"># 端口</span>
    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> /hmall <span class="token comment"># 虚拟主机</span>
    <span class="token key atrule">username</span><span class="token punctuation">:</span> hmall <span class="token comment"># 用户名</span>
    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123</span> <span class="token comment"># 密码</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在<code>publisher</code>服务中编写测试类<code>SpringAmqpTest</code>，并利用<code>RabbitTemplate</code>实现消息发送：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>publisher<span class="token punctuation">.</span>amqp</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RabbitTemplate</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">SpringBootTest</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@SpringBootTest</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAmqpTest</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSimpleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 队列名称</span>
        <span class="token class-name">String</span> queueName <span class="token operator">=</span> <span class="token string">&quot;simple.queue&quot;</span><span class="token punctuation">;</span>
        <span class="token comment">// 消息</span>
        <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">&quot;hello, spring amqp!&quot;</span><span class="token punctuation">;</span>
        <span class="token comment">// 发送消息</span>
        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3）消息接收</strong></p><p>首先配置MQ地址，在<code>consumer</code>服务的<code>application.yml</code>中添加配置：</p><div class="language-YAML line-numbers-mode" data-ext="YAML" data-title="YAML"><pre class="language-YAML"><code>spring:
  rabbitmq:
    host: 192.168.150.101 # 你的虚拟机IP
    port: 5672 # 端口
    virtual-host: /hmall # 虚拟主机
    username: hmall # 用户名
    password: 123 # 密码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在<code>consumer</code>服务的<code>com.itheima.consumer.listener</code>包中新建一个类<code>SpringRabbitListener</code>，代码如下：</p><div class="language-Java line-numbers-mode" data-ext="Java" data-title="Java"><pre class="language-Java"><code>package com.itheima.consumer.listener;

import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

@Component
public class SpringRabbitListener {
        // 利用RabbitListener来声明要监听的队列信息
    // 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。
    // 可以看到方法体中接收的就是消息体的内容
    @RabbitListener(queues = &quot;simple.queue&quot;)
    public void listenSimpleQueueMessage(String msg) throws InterruptedException {
        System.out.println(&quot;spring 消费者接收到消息：【&quot; + msg + &quot;】&quot;);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3、workqueues模型" tabindex="-1"><a class="header-anchor" href="#_3、workqueues模型"><span>3、WorkQueues模型</span></a></h3><p><code>Work queues</code>，任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><figure><img src="`+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><h4 id="_1-模拟多个消息接收者" tabindex="-1"><a class="header-anchor" href="#_1-模拟多个消息接收者"><span><strong>1）模拟多个消息接收者</strong></span></a></h4><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><div class="language-Java line-numbers-mode" data-ext="Java" data-title="Java"><pre class="language-Java"><code>@RabbitListener(queues = &quot;work.queue&quot;)
public void listenWorkQueue1(String msg) throws InterruptedException {
    System.out.println(&quot;消费者1接收到消息：【&quot; + msg + &quot;】&quot; + LocalTime.now());
    Thread.sleep(20);
}

@RabbitListener(queues = &quot;work.queue&quot;)
public void listenWorkQueue2(String msg) throws InterruptedException {
    System.err.println(&quot;消费者2........接收到消息：【&quot; + msg + &quot;】&quot; + LocalTime.now());
    Thread.sleep(200);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意到这两消费者，都设置了<code>Thead.sleep</code>，模拟任务耗时：</p><ul><li>消费者1 sleep了20毫秒，相当于每秒钟处理50个消息</li><li>消费者2 sleep了200毫秒，相当于每秒处理5个消息</li></ul><h4 id="_2-启动测试" tabindex="-1"><a class="header-anchor" href="#_2-启动测试"><span><strong>2）启动测试</strong></span></a></h4><p>发现消费者1和消费者2竟然每人消费了25条消息，也就是说消息是<strong>平均分配给每个消费者</strong>，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。<strong>没有充分利用每一个消费者的能力</strong>，最终消息处理的耗时远远超过了1秒。这样显然是有问题的。</p><h4 id="_3-解决方案-能者多劳" tabindex="-1"><a class="header-anchor" href="#_3-解决方案-能者多劳"><span><strong>3）解决方案--能者多劳</strong></span></a></h4><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><div class="language-YAML line-numbers-mode" data-ext="YAML" data-title="YAML"><pre class="language-YAML"><code>spring:
  rabbitmq:
    listener:
      simple:
        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次测试发现由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。</p><h4 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结"><span><strong>4）总结</strong></span></a></h4><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="五、交换机类型" tabindex="-1"><a class="header-anchor" href="#五、交换机类型"><span>五、交换机类型</span></a></h2><p>在之前的两个测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：</p><figure><img src="`+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li><li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li><li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定。</li><li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><div class="hint-container tip"><p class="hint-container-title">交换机的类型有四种：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li></ul></div><h3 id="_1、fanout交换机" tabindex="-1"><a class="header-anchor" href="#_1、fanout交换机"><span>1、Fanout交换机</span></a></h3><p><code>Fanout</code>，英文翻译是扇出，我觉得在MQ中叫<strong>广播</strong>更合适。</p><p>在广播模式下，消息发送流程是这样的：</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>1） 可以有多个队列</li><li>2） 每个队列都要绑定到Exchange（交换机）</li><li>3） 生产者发送的消息，只能发送到交换机</li><li>4） 交换机把消息发送给绑定过的所有队列</li><li>5） 订阅队列的消费者都能拿到消息</li></ul><h3 id="_2、direct交换机" tabindex="-1"><a class="header-anchor" href="#_2、direct交换机"><span>2、Direct交换机</span></a></h3><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>在Direct模型下：</strong></p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><div class="hint-container tip"><p class="hint-container-title">Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul></div><h3 id="_3、topic交换机" tabindex="-1"><a class="header-anchor" href="#_3、topic交换机"><span>3、Topic交换机</span></a></h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。</p><p>只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>BindingKey</code> 的时候使用通配符！</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>BindingKey` 一般都是有一个或多个单词组成，多个单词之间以`.`分割，例如： `item.insert\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">通配符规则：</p><ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配恰好1个词</li></ul></div><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></li><li><code>item.*</code>：只能匹配<code>item.spu</code></li></ul><div class="hint-container tip"><p class="hint-container-title">Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <strong><code>.</code></strong> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul></div><h2 id="六、声明队列和交换机" tabindex="-1"><a class="header-anchor" href="#六、声明队列和交换机"><span>六、声明队列和交换机</span></a></h2><p>在之前我们都是基于RabbitMQ控制台来创建队列、交换机，在这个过程中是很容易出现错误的。</p><p>因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。</p><h3 id="_1、基本api" tabindex="-1"><a class="header-anchor" href="#_1、基本api"><span>1、基本API</span></a></h3><p>SpringAMQP提供了一个Queue类，用来创建队列：</p><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>SpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机：</p><figure><img src="'+b+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们可以自己创建队列和交换机，不过SpringAMQP还提供了<code>ExchangeBuilder</code>来简化这个过程,而在绑定队列和交换机时，则需要使用<code>BindingBuilder</code>来创建Binding对象。</p><h3 id="_2、示例" tabindex="-1"><a class="header-anchor" href="#_2、示例"><span>2、示例</span></a></h3><p>在consumer中创建一个类，声明队列和交换机：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">Binding</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">BindingBuilder</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">FanoutExchange</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">Queue</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FanoutConfig</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * 声明交换机
     * <span class="token keyword">@return</span> Fanout类型交换机
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">FanoutExchange</span> <span class="token function">fanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FanoutExchange</span><span class="token punctuation">(</span><span class="token string">&quot;hmall.fanout&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 第1个队列
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">fanoutQueue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">&quot;fanout.queue1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 绑定队列和交换机
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingQueue1</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> fanoutQueue1<span class="token punctuation">,</span> <span class="token class-name">FanoutExchange</span> fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fanoutQueue1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 第2个队列
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">fanoutQueue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">&quot;fanout.queue2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 绑定队列和交换机
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingQueue2</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> fanoutQueue2<span class="token punctuation">,</span> <span class="token class-name">FanoutExchange</span> fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fanoutQueue2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于direct模式要绑定多个KEY，使用这种方式会非常麻烦，每一个Key都要编写一个binding</p><h3 id="_3、基于注解声明" tabindex="-1"><a class="header-anchor" href="#_3、基于注解声明"><span>3、基于注解声明</span></a></h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>例如，我们同样声明Direct模式的交换机和队列：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>
    value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;direct.queue1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;hmall.direct&quot;</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span><span class="token constant">DIRECT</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDirectQueue1</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">&quot;】&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>
    value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;direct.queue2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;hmall.direct&quot;</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">ExchangeTypes</span><span class="token punctuation">.</span><span class="token constant">DIRECT</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    key <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;yellow&quot;</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDirectQueue2</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">&quot;】&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="七、消息转换器" tabindex="-1"><a class="header-anchor" href="#七、消息转换器"><span>七、消息转换器</span></a></h2><p>Spring的消息发送代码接收的消息体是一个Object，而在数据传输时，它会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><h3 id="_1、配置json转换器" tabindex="-1"><a class="header-anchor" href="#_1、配置json转换器"><span>1、配置JSON转换器</span></a></h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在<code>publisher</code>和<code>consumer</code>两个服务中都引入依赖：</p><div class="language-XML line-numbers-mode" data-ext="XML" data-title="XML"><pre class="language-XML"><code>&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;
    &lt;version&gt;2.9.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注意</p><p>如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。</p></div><p>配置消息转换器，在<code>publisher</code>和<code>consumer</code>两个服务的启动类中添加一个Bean即可：</p><div class="language-Java line-numbers-mode" data-ext="Java" data-title="Java"><pre class="language-Java"><code>@Bean
public MessageConverter messageConverter(){
    // 1.定义消息转换器
    Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();
    // 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息
    jackson2JsonMessageConverter.setCreateMessageIds(true);
    return jackson2JsonMessageConverter;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>消息转换器中添加的messageId可以便于我们将来做幂等性判断。</p><h2 id="八、业务改造" tabindex="-1"><a class="header-anchor" href="#八、业务改造"><span>八、业务改造</span></a></h2><p>案例需求：改造余额支付功能，将支付成功后基于OpenFeign的交易服务的更新订单状态接口的同步调用，改为基于RabbitMQ的异步通知。</p><p>如图：</p><figure><img src="`+h+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>说明：目前没有通知服务和积分服务，因此我们只关注交易服务</p><div class="hint-container info"><p class="hint-container-title">步骤如下：</p><ul><li>定义<code>direct</code>类型交换机，命名为<code>pay.direct</code></li><li>定义消息队列，命名为<code>trade.pay.success.queue</code></li><li>将<code>trade.pay.success.queue</code>与<code>pay.direct</code>绑定，<code>BindingKey</code>为<code>pay.success</code></li><li>支付成功时不再调用交易服务更新订单状态的接口，而是发送一条消息到<code>pay.direct</code>，发送消息的<code>RoutingKey</code> 为<code>pay.success</code>，消息内容是订单id</li><li>交易服务监听<code>trade.pay.success.queue</code>队列，接收到消息后更新订单状态为已支付</li></ul></div><h3 id="_1、配置mq" tabindex="-1"><a class="header-anchor" href="#_1、配置mq"><span>1、配置MQ</span></a></h3><p>不管是生产者还是消费者，都需要配置MQ的基本信息。分为两步：</p><p><strong>1）添加依赖：</strong></p><div class="language-XML line-numbers-mode" data-ext="XML" data-title="XML"><pre class="language-XML"><code>  &lt;!--消息发送--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
  &lt;/dependency&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2）配置MQ地址：</strong></p><div class="language-YAML line-numbers-mode" data-ext="YAML" data-title="YAML"><pre class="language-YAML"><code>spring:
  rabbitmq:
    host: 192.168.175.129 # 你的虚拟机IP
    port: 5672 # 端口
    virtual-host: /hmall # 虚拟主机
    username: hmall # 用户名
    password: 123 # 密码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、接收消息" tabindex="-1"><a class="header-anchor" href="#_2、接收消息"><span>2、接收消息</span></a></h3><p>在trade-service服务中定义一个消息监听类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@RequiredArgsConstructor</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PayStatusListener</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">IOrderService</span> orderService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>
            value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;trade.pay.success.queue&quot;</span><span class="token punctuation">,</span> durable <span class="token operator">=</span> <span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;pay.topic&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            key <span class="token operator">=</span> <span class="token string">&quot;pay.success&quot;</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenPaySuccess</span><span class="token punctuation">(</span><span class="token class-name">Long</span> orderId<span class="token punctuation">)</span><span class="token punctuation">{</span>
        orderService<span class="token punctuation">.</span><span class="token function">markOrderPaySuccess</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3、发送消息" tabindex="-1"><a class="header-anchor" href="#_3、发送消息"><span>3、发送消息</span></a></h3><p>修改<code>pay-service</code>服务下的<code>com.hmall.pay.service.impl.PayOrderServiceImpl</code>类中的<code>tryPayOrderByBalance</code>方法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code> 	<span class="token comment">// 5.修改订单状态</span>
    <span class="token comment">// tradeClient.markOrderPaySuccess(po.getBizOrderNo());</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">&quot;pay.direct&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;pay.success&quot;</span><span class="token punctuation">,</span> po<span class="token punctuation">.</span><span class="token function">getBizOrderNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;支付成功的消息发送失败，支付单id：{}， 交易单id：{}&quot;</span><span class="token punctuation">,</span> po<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> po<span class="token punctuation">.</span><span class="token function">getBizOrderNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,153);function q(_,x){return t(),s("div",null,[a("more-"),y])}const w=n(f,[["render",q],["__file","8_MQ基础.html.vue"]]),R=JSON.parse('{"path":"/posts/%E5%90%8E%E7%AB%AF/springcloud/8_MQ%E5%9F%BA%E7%A1%80.html","title":"MQ基础","lang":"zh-CN","frontmatter":{"title":"MQ基础","date":"2024-06-27T11:19:00.000Z","tags":"SpringCloud","category":"SpringCloud","order":8,"icon":"/img/rabbitmq.svg","description":"MQ基础 一、异步通讯 目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要等待服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为同步调用，也可以叫同步通讯。但在很多场景下，我们可能需要采用异步通讯的方式，为什么呢？ 我们先来看看什么是同步通讯和...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/%E5%90%8E%E7%AB%AF/springcloud/8_MQ%E5%9F%BA%E7%A1%80.html"}],["meta",{"property":"og:site_name","content":"Lance"}],["meta",{"property":"og:title","content":"MQ基础"}],["meta",{"property":"og:description","content":"MQ基础 一、异步通讯 目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要等待服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为同步调用，也可以叫同步通讯。但在很多场景下，我们可能需要采用异步通讯的方式，为什么呢？ 我们先来看看什么是同步通讯和..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/image/cloud/cloud21.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-09T11:07:04.000Z"}],["meta",{"property":"article:author","content":"RuyiWei"}],["meta",{"property":"article:published_time","content":"2024-06-27T11:19:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-09T11:07:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MQ基础\\",\\"image\\":[\\"https://mister-hope.github.io/image/cloud/cloud21.png\\",\\"https://mister-hope.github.io/image/cloud/cloud22.png\\",\\"https://mister-hope.github.io/image/cloud/cloud23.png\\",\\"https://mister-hope.github.io/image/cloud/cloud24.png\\",\\"https://mister-hope.github.io/image/cloud/cloud25.png\\",\\"https://mister-hope.github.io/image\\\\\\\\cloud\\\\\\\\cloud26.png\\",\\"https://mister-hope.github.io/image\\\\\\\\cloud\\\\\\\\cloud27.png\\",\\"https://mister-hope.github.io/image\\\\\\\\cloud\\\\\\\\cloud28.png\\",\\"https://mister-hope.github.io/image\\\\\\\\cloud\\\\\\\\cloud29.png\\",\\"https://mister-hope.github.io/image\\\\\\\\cloud\\\\\\\\cloud30.png\\",\\"https://mister-hope.github.io/image\\\\\\\\cloud\\\\\\\\cloud31.png\\",\\"https://mister-hope.github.io/image\\\\\\\\cloud\\\\\\\\cloud32.png\\",\\"https://mister-hope.github.io/image\\\\\\\\cloud\\\\\\\\cloud33.png\\",\\"https://mister-hope.github.io/image\\\\\\\\cloud\\\\\\\\cloud34.png\\"],\\"datePublished\\":\\"2024-06-27T11:19:00.000Z\\",\\"dateModified\\":\\"2024-08-09T11:07:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"RuyiWei\\"}]}"]]},"headers":[{"level":2,"title":"一、异步通讯","slug":"一、异步通讯","link":"#一、异步通讯","children":[]},{"level":2,"title":"二、MQ","slug":"二、mq","link":"#二、mq","children":[{"level":3,"title":"1、同步调用","slug":"_1、同步调用","link":"#_1、同步调用","children":[]},{"level":3,"title":"2、异步调用","slug":"_2、异步调用","link":"#_2、异步调用","children":[]}]},{"level":2,"title":"三、技术选型","slug":"三、技术选型","link":"#三、技术选型","children":[{"level":3,"title":"1、常见MQ介绍","slug":"_1、常见mq介绍","link":"#_1、常见mq介绍","children":[]},{"level":3,"title":"2、RabbitMQ","slug":"_2、rabbitmq","link":"#_2、rabbitmq","children":[]}]},{"level":2,"title":"四、SpringAMQP","slug":"四、springamqp","link":"#四、springamqp","children":[{"level":3,"title":"1、介绍","slug":"_1、介绍","link":"#_1、介绍","children":[]},{"level":3,"title":"2、使用","slug":"_2、使用","link":"#_2、使用","children":[]},{"level":3,"title":"3、WorkQueues模型","slug":"_3、workqueues模型","link":"#_3、workqueues模型","children":[]}]},{"level":2,"title":"五、交换机类型","slug":"五、交换机类型","link":"#五、交换机类型","children":[{"level":3,"title":"1、Fanout交换机","slug":"_1、fanout交换机","link":"#_1、fanout交换机","children":[]},{"level":3,"title":"2、Direct交换机","slug":"_2、direct交换机","link":"#_2、direct交换机","children":[]},{"level":3,"title":"3、Topic交换机","slug":"_3、topic交换机","link":"#_3、topic交换机","children":[]}]},{"level":2,"title":"六、声明队列和交换机","slug":"六、声明队列和交换机","link":"#六、声明队列和交换机","children":[{"level":3,"title":"1、基本API","slug":"_1、基本api","link":"#_1、基本api","children":[]},{"level":3,"title":"2、示例","slug":"_2、示例","link":"#_2、示例","children":[]},{"level":3,"title":"3、基于注解声明","slug":"_3、基于注解声明","link":"#_3、基于注解声明","children":[]}]},{"level":2,"title":"七、消息转换器","slug":"七、消息转换器","link":"#七、消息转换器","children":[{"level":3,"title":"1、配置JSON转换器","slug":"_1、配置json转换器","link":"#_1、配置json转换器","children":[]}]},{"level":2,"title":"八、业务改造","slug":"八、业务改造","link":"#八、业务改造","children":[{"level":3,"title":"1、配置MQ","slug":"_1、配置mq","link":"#_1、配置mq","children":[]},{"level":3,"title":"2、接收消息","slug":"_2、接收消息","link":"#_2、接收消息","children":[]},{"level":3,"title":"3、发送消息","slug":"_3、发送消息","link":"#_3、发送消息","children":[]}]}],"git":{"createdTime":1723201624000,"updatedTime":1723201624000,"contributors":[{"name":"yqiChen","email":"chenyuqi1229@gmail.com","commits":1}]},"readingTime":{"minutes":15.61,"words":4682},"filePathRelative":"posts/后端/springcloud/8_MQ基础.md","localizedDate":"2024年6月27日","excerpt":"<!--more--->\\n<h1>MQ基础</h1>\\n<h2>一、异步通讯</h2>\\n<p>目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要<strong>等待</strong>服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为<strong>同步调用</strong>，也可以叫<strong>同步通讯</strong>。但在很多场景下，我们可能需要采用<strong>异步通讯</strong>的方式，为什么呢？</p>\\n<p>我们先来看看什么是同步通讯和异步通讯。如图：</p>\\n<figure><img src=\\"/image/cloud/cloud21.png\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>","autoDesc":true}');export{w as comp,R as data};
