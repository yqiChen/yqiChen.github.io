import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,c as p,a as r,d as e,w as a,b as t,e as n,f as l,o as d}from"./app-jl_0F-Zm.js";const u="/image/cloud/cloud6.png",g="/image/cloud/cloud7.png",m="/image/cloud/cloud8.jpg",h="/image/cloud/cloud8.png",i="/image/cloud/cloud9.png",v="/image/cloud/cloud10.png",k="/image/cloud/cloud11.png",b="/image/cloud/cloud12.png",_="/image/cloud/cloud13.png",f="/image/cloud/cloud14.png",y="/image/cloud/cloud15.png",x="/image/cloud/cloud16.png",C={},A=t('<h1 id="服务保护" tabindex="-1"><a class="header-anchor" href="#服务保护"><span>服务保护</span></a></h1><h2 id="一、介绍" tabindex="-1"><a class="header-anchor" href="#一、介绍"><span>一、介绍</span></a></h2><p>在微服务远程调用的过程中，还存在几个问题需要解决。</p><p>首先是<strong>业务健壮性</strong>问题：</p><p>例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服 务时，是不是也会异常？从而导致购物车查询失败。但从业务角度来说，为了提升用户体验，即便是商品查询失败，购物车列表也应该正确展示出来，哪怕是不包含最新的商品信息。</p><p>还有<strong>级联失败</strong>问题：</p><p>还是查询购物车的业务，假如商品服务业务并发较高，占用过多Tomcat连接。可能会导致商品服务的所有接口响应时间增加，延迟变高，甚至是长时间阻塞直至查询失败。</p><p>此时查询购物车业务需要查询并等待商品查询结果，从而导致查询购物车列表业务的响应时间也变长，甚至也阻塞直至无法访问。而此时如果查询购物车的请求较多，可能导致购物车服务的Tomcat连接占用较多，所有接口的响应时间都会增加，整个服务性能很差， 甚至不可用。</p>',8),S=n("img",{src:u,style:{zoom:"50%"}},null,-1),F=n("p",null,"依次类推，整个微服务群中与购物车服务、商品服务等有调用关系的服务可能都会出现问题，最终导致整个集群不可用。",-1),w=n("img",{src:g,style:{zoom:"50%"}},null,-1),L=t('<p>这就是<strong>级联失败</strong>问题，或者叫<strong>雪崩</strong>问题。</p><h2 id="二、解决方案" tabindex="-1"><a class="header-anchor" href="#二、解决方案"><span>二、解决方案</span></a></h2><div class="hint-container info"><p class="hint-container-title">微服务保护方案</p><ul><li>请求限流</li><li>线程隔离</li><li>服务熔断</li></ul></div><p>这些方案或多或少都会导致服务的体验上略有下降，比如:</p><ul><li><p>请求限流，降低了并发上限；线程隔离，降低了可用资源数量；</p></li><li><p>服务熔断，降低了服务的完整度，部分服务变的不可用或弱可用。</p></li></ul><p>因此这些方案都属于服务<strong>降级</strong>的方案。但通过这些方案，服务的健壮性得到了提升，</p><h3 id="_1、请求限流" tabindex="-1"><a class="header-anchor" href="#_1、请求限流"><span>1、请求限流</span></a></h3><p>服务故障最重要原因，就是并发太高！解决了这个问题，就能避免大部分故障。当然，接口的并发不是一直很高，而是突发的。因此请求限流，就是<strong>限制或控制</strong>接口访问的并发流量，避免服务因流量激增而出现故障。</p><p>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。这就像是水电站的大坝，起到蓄水的作用，可以通过开关控制水流出的大小，让下游水流始终维持在一个平稳的量</p>',9),E=n("img",{src:m,style:{zoom:"50%"}},null,-1),I=n("h3",{id:"_2、线程隔离",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_2、线程隔离"},[n("span",null,"2、线程隔离")])],-1),M=n("p",null,"当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以我们必须把这种影响降低，或者缩减影响的范围。线程隔离正是解决这个问题的好办法。",-1),j=n("p",null,"线程隔离的思想来自轮船的舱壁模式：",-1),D=n("img",{src:h},null,-1),z=n("p",null,"为了避免某个接口故障或压力过大导致整个服务不可用，我们可以限定每个接口可以使用的资源范围，也就是将其“隔离”起来。",-1),T=n("img",{src:i,style:{zoom:"50%"}},null,-1),Y=n("p",null,"如图所示，我们给查询购物车业务限定可用线程数量上限为20，这样即便查询购物车的请求因为查询商品服务而出现故障，也不会导致服务器的线程资源被耗尽，不会影响到其它接口。",-1),B=n("h3",{id:"_3、服务熔断",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_3、服务熔断"},[n("span",null,"3、服务熔断")])],-1),O=n("p",null,"线程隔离虽然避免了雪崩问题，但故障服务（商品服务）依然会拖慢购物车服务（服务调用方）的接口响应速度。而且商品查询的故障依然会导致查询购物车功能出现故障，购物车业务也变的不可用了。",-1),q=n("p",null,"所以，我们要做两件事情：",-1),N=n("ul",null,[n("li",null,[n("strong",null,"编写服务降级逻辑"),l("：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。")]),n("li",null,[n("strong",null,"异常统计和熔断"),l("：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。")])],-1),P=n("img",{src:v,style:{zoom:"50%"}},null,-1),V=t(`<h2 id="三、sentinel" tabindex="-1"><a class="header-anchor" href="#三、sentinel"><span>三、Sentinel</span></a></h2><p>微服务保护的技术有很多，但在目前国内使用较多的还是Sentinel。</p><h3 id="_1、介绍和安装" tabindex="-1"><a class="header-anchor" href="#_1、介绍和安装"><span>1、介绍和安装</span></a></h3><p>Sentinel是阿里巴巴开源的一款服务保护框架，目前已经加入SpringCloudAlibaba中，<a href="https://sentinelguard.io/zh-cn/" target="_blank" rel="noopener noreferrer">官方网站</a></p><div class="hint-container tip"><p class="hint-container-title">Sentinel 的使用可以分为两个部分:</p><ul><li><strong>核心库</strong>（Jar包）：不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能。</li><li><strong>控制台</strong>（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。</li></ul></div><p><strong>1）下载jar包</strong></p><p>下载地址：<a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/Sentinel/releases</a></p><p><strong>2）运行</strong></p><p>将jar包放在任意非中文、不包含特殊字符的目录下，重命名为<code>sentinel-dashboard.jar</code></p><p>然后运行如下命令启动控制台：</p><div class="language-Shell line-numbers-mode" data-ext="Shell" data-title="Shell"><pre class="language-Shell"><code>java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其它启动时可配置参数可参考<a href="https://github.com/alibaba/Sentinel/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9" target="_blank" rel="noopener noreferrer">官方文档</a></p><p><strong>3）访问</strong></p><p>访问<a href="http://localhost:8080" target="_blank" rel="noopener noreferrer">http://localhost:8090</a>页面，就可以看到sentinel的控制台了：</p>`,14),Z=n("img",{src:k},null,-1),Q=t(`<p>需要输入账号和密码，默认都是：sentinel 。登录后，即可看到控制台，默认会监控sentinel-dashboard服务本身</p><h3 id="_2、微服务整合" tabindex="-1"><a class="header-anchor" href="#_2、微服务整合"><span>2、微服务整合</span></a></h3><p>我们在<code>cart-service</code>模块中整合sentinel，连接<code>sentinel-dashboard</code>控制台，步骤如下：</p><p><strong>1）引入sentinel依赖</strong></p><div class="language-XML line-numbers-mode" data-ext="XML" data-title="XML"><pre class="language-XML"><code>&lt;!--sentinel--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; 
    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2）配置控制台</strong></p><p>修改application.yaml文件，添加下面内容：</p><div class="language-YAML line-numbers-mode" data-ext="YAML" data-title="YAML"><pre class="language-YAML"><code>spring:
  cloud: 
    sentinel:
      transport:
        dashboard: localhost:8090
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3）访问<code>cart-service</code>的任意端点</strong></p><p>重启<code>cart-service</code>，然后访问查询购物车接口，sentinel的客户端就会将服务访问的信息提交到<code>sentinel-dashboard</code>控制台。并展示出统计信息：</p><h3 id="_3、簇点链路" tabindex="-1"><a class="header-anchor" href="#_3、簇点链路"><span>3、簇点链路</span></a></h3><p>簇点链路，就是单机调用链路，是一次请求进入服务后经过的每一个被<code>Sentinel</code>监控的资源。默认情况下，<code>Sentinel</code>会监控<code>SpringMVC</code>的每一个<code>Endpoint</code>（接口）。因此，我们看到<code>/carts</code>这个接口路径就是其中一个簇点，我们可以对其进行限流、熔断、隔离等保护措施。</p><p>不过，需要注意的是，我们的SpringMVC接口是按照Restful风格设计，因此购物车的查询、删除、修改等接口全部都是<code>/carts</code>路径：</p><p>默认情况下Sentinel会把路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的。</p><p>所以我们可以选择打开Sentinel的请求方式前缀，把<code>请求方式 + 请求路径</code>作为簇点资源名：</p><p>首先，在<code>cart-service</code>的<code>application.yml</code>中添加下面的配置：</p><div class="language-YAML line-numbers-mode" data-ext="YAML" data-title="YAML"><pre class="language-YAML"><code>spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8090
      http-method-specify: true # 开启请求方式前缀
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，重启服务，通过页面访问购物车的相关接口，可以看到sentinel控制台的簇点链路发生了变化。</p><h3 id="_4、请求限流" tabindex="-1"><a class="header-anchor" href="#_4、请求限流"><span>4、请求限流</span></a></h3><p>在簇点链路后面点击流控按钮，即可对其做限流配置，在弹出的菜单中这样填写：</p><figure><img src="`+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这样就把查询购物车列表这个簇点资源的流量限制在了每秒6个，也就是最大QPS为6.</p><h3 id="_5、线程隔离" tabindex="-1"><a class="header-anchor" href="#_5、线程隔离"><span>5、线程隔离</span></a></h3><p>限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩。</p><p>比如，查询购物车的时候需要查询商品，为了避免因商品服务出现故障导致购物车服务级联失败，我们可以把购物车业务中查询商品的部分隔离起来，限制可用的线程资源：</p>',25),R=n("img",{src:i,style:{zoom:"50%"}},null,-1),J=t(`<p>这样，即便商品服务出现故障，最多导致查询购物车业务故障，并且可用的线程资源也被限定在一定范围，不会导致整个购物车服务崩溃。所以，我们要对查询商品的FeignClient接口做线程隔离。</p><p><strong>1）OpenFeign整合Sentinel</strong></p><p>修改cart-service模块的application.yml文件，开启Feign的sentinel功能：</p><div class="language-YAML line-numbers-mode" data-ext="YAML" data-title="YAML"><pre class="language-YAML"><code>feign:
  sentinel:
    enabled: true # 开启feign对sentinel的支持
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注意</p><p>需要注意的是，默认情况下SpringBoot项目的tomcat最大线程数是200，允许的最大连接是8492，单机测试很难打满。</p></div><p>所以我们需要配置一下cart-service模块的application.yml文件，修改tomcat连接：</p><div class="language-YAML line-numbers-mode" data-ext="YAML" data-title="YAML"><pre class="language-YAML"><code>server:
  port: 8082
  tomcat:
    threads:
      max: 50 # 允许的最大线程数
    accept-count: 50 # 最大排队等待数量
    max-connections: 100 # 允许的最大连接
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后重启cart-service服务，可以看到查询商品的FeignClient自动变成了一个簇点资源。</p><figure><img src="`+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>2）配置线程隔离</strong></p><p>接下来，点击查询商品的FeignClient对应的簇点资源后面的流控按钮，在弹出的表单中填写下面内容：</p><figure><img src="'+f+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>注意：</strong> 这里勾选的是并发线程数限制，也就是说这个查询功能最多使用5个线程，而不是5QPS。如果查询商品的接口每秒处理2个请求，则5个线程的实际QPS在10左右，而超出的请求自然会被拒绝。</p><h3 id="_6、服务熔断" tabindex="-1"><a class="header-anchor" href="#_6、服务熔断"><span>6、服务熔断</span></a></h3><p>我们利用线程隔离对查询购物车业务进行隔离，保护了购物车服务的其它接口。由于查询商品的功能耗时较高（我们模拟了500毫秒延时），再加上线程隔离限定了线程数为5，导致接口吞吐能力有限，最终QPS只有10左右。这就导致了几个问题：</p><p>第一，超出的QPS上限的请求就只能抛出异常，从而导致购物车的查询失败。但从业务角度来说，即便没有查询到最新的商品信息，购物车也应该展示给用户，用户体验更好。也就是给查询失败设置一个<strong>降级处理</strong>逻辑。</p><p>第二，由于查询商品的延迟较高（模拟的500ms），从而导致查询购物车的响应时间也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。对于商品服务这种不太健康的接口，我们应该直接停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。</p><p><strong>1）编写降级逻辑</strong></p><p>触发限流或熔断后的请求不一定要直接报错，也可以返回一些默认数据或者友好提示，用户体验会更好。</p><p>给FeignClient编写失败后的降级逻辑有两种方式：</p><ul><li>方式一：FallbackClass，无法对远程调用的异常做处理</li><li>方式二：FallbackFactory，可以对远程调用的异常做处理，我们一般选择这种方式。</li></ul><p>这里我们演示方式二的失败降级处理。</p><p><strong>步骤一</strong>：在hm-api模块中给<code>ItemClient</code>定义降级处理类，实现<code>FallbackFactory</code>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ItemClientFallback</span> <span class="token keyword">implements</span> <span class="token class-name">FallbackFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ItemClient</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">ItemClient</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ItemClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ItemDTO</span><span class="token punctuation">&gt;</span></span> <span class="token function">queryItemByIds</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> ids<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;远程调用ItemClient#queryItemByIds方法出现异常，参数：{}&quot;</span><span class="token punctuation">,</span> ids<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 查询购物车允许失败，查询失败，返回空集合</span>
                <span class="token keyword">return</span> <span class="token class-name">CollUtils</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deductStock</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OrderDetailDTO</span><span class="token punctuation">&gt;</span></span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 库存扣减业务需要触发事务回滚，查询失败，抛出异常</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BizIllegalException</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>步骤二</strong>：在<code>hm-api</code>模块中的<code>com.hmall.api.config.DefaultFeignConfig</code>类中将<code>ItemClientFallback</code>注册为一个<code>Bean</code></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>	<span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">ItemClientFallbackFactory</span> <span class="token function">itemClientFallbackFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ItemClientFallbackFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>步骤三</strong>：在<code>hm-api</code>模块中的<code>ItemClient</code>接口中使用<code>ItemClientFallbackFactory</code>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;item-service&quot;</span><span class="token punctuation">,</span> fallbackFactory <span class="token operator">=</span> <span class="token class-name">ItemClientFallbackFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ItemClient</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启后，再次测试，发现被限流的请求不再报错，走了降级逻辑。</p><p><strong>2）服务熔断</strong></p><p>Sentinel中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求比例</strong>。当这些比例超出阈值时，就会<strong>熔断</strong>该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。</p><p>断路器的工作状态切换有一个状态机来控制：</p><figure><img src="`+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container info"><p class="hint-container-title">状态机包括三个状态：</p><ul><li><strong>closed</strong>：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li><strong>open</strong>：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li><strong>half-open</strong>：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 <ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态</li></ul></li></ul></div><p>我们可以在控制台通过点击簇点后的 <strong><code>熔断</code></strong> 按钮来配置熔断策略：</p><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这种是按照慢调用比例来做熔断，上述配置的含义是：</p><ul><li>RT超过200毫秒的请求调用就是慢调用</li><li>统计最近1000ms内的最少5次请求，如果慢调用比例不低于0.5，则触发熔断</li><li>熔断持续时长20s</li></ul><p>配置完成后，再次利用Jemeter测试。</p>',39);function X(W,U){const s=c("center");return d(),p("div",null,[r("more-"),A,e(s,null,{default:a(()=>[S]),_:1}),F,e(s,null,{default:a(()=>[w]),_:1}),L,e(s,null,{default:a(()=>[E]),_:1}),I,M,j,e(s,null,{default:a(()=>[D]),_:1}),z,e(s,null,{default:a(()=>[T]),_:1}),Y,B,O,q,N,e(s,null,{default:a(()=>[P]),_:1}),V,e(s,null,{default:a(()=>[Z]),_:1}),Q,e(s,null,{default:a(()=>[R]),_:1}),J])}const K=o(C,[["render",X],["__file","6_服务保护.html.vue"]]),$=JSON.parse('{"path":"/posts/%E5%90%8E%E7%AB%AF/springcloud/6_%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4.html","title":"服务保护","lang":"zh-CN","frontmatter":{"title":"服务保护","date":"2024-06-26T14:00:00.000Z","tags":"SpringCloud","category":"SpringCloud","order":6,"icon":"/img/sentinel.svg","description":"服务保护 一、介绍 在微服务远程调用的过程中，还存在几个问题需要解决。 首先是业务健壮性问题： 例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服 务时，是不是也会异常？从而导致购物车查询失败。但从业务角度来说，为了提升用户体验，即便是商...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/%E5%90%8E%E7%AB%AF/springcloud/6_%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4.html"}],["meta",{"property":"og:site_name","content":"Lance"}],["meta",{"property":"og:title","content":"服务保护"}],["meta",{"property":"og:description","content":"服务保护 一、介绍 在微服务远程调用的过程中，还存在几个问题需要解决。 首先是业务健壮性问题： 例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服 务时，是不是也会异常？从而导致购物车查询失败。但从业务角度来说，为了提升用户体验，即便是商..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/image/cloud/cloud12.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-09T11:07:04.000Z"}],["meta",{"property":"article:author","content":"RuyiWei"}],["meta",{"property":"article:published_time","content":"2024-06-26T14:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-09T11:07:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"服务保护\\",\\"image\\":[\\"https://mister-hope.github.io/image/cloud/cloud12.png\\",\\"https://mister-hope.github.io/image/cloud/cloud13.png\\",\\"https://mister-hope.github.io/image/cloud/cloud14.png\\",\\"https://mister-hope.github.io/image/cloud/cloud15.png\\",\\"https://mister-hope.github.io/image/cloud/cloud16.png\\"],\\"datePublished\\":\\"2024-06-26T14:00:00.000Z\\",\\"dateModified\\":\\"2024-08-09T11:07:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"RuyiWei\\"}]}"]]},"headers":[{"level":2,"title":"一、介绍","slug":"一、介绍","link":"#一、介绍","children":[]},{"level":2,"title":"二、解决方案","slug":"二、解决方案","link":"#二、解决方案","children":[{"level":3,"title":"1、请求限流","slug":"_1、请求限流","link":"#_1、请求限流","children":[]},{"level":3,"title":"2、线程隔离","slug":"_2、线程隔离","link":"#_2、线程隔离","children":[]},{"level":3,"title":"3、服务熔断","slug":"_3、服务熔断","link":"#_3、服务熔断","children":[]}]},{"level":2,"title":"三、Sentinel","slug":"三、sentinel","link":"#三、sentinel","children":[{"level":3,"title":"1、介绍和安装","slug":"_1、介绍和安装","link":"#_1、介绍和安装","children":[]},{"level":3,"title":"2、微服务整合","slug":"_2、微服务整合","link":"#_2、微服务整合","children":[]},{"level":3,"title":"3、簇点链路","slug":"_3、簇点链路","link":"#_3、簇点链路","children":[]},{"level":3,"title":"4、请求限流","slug":"_4、请求限流","link":"#_4、请求限流","children":[]},{"level":3,"title":"5、线程隔离","slug":"_5、线程隔离","link":"#_5、线程隔离","children":[]},{"level":3,"title":"6、服务熔断","slug":"_6、服务熔断","link":"#_6、服务熔断","children":[]}]}],"git":{"createdTime":1723201624000,"updatedTime":1723201624000,"contributors":[{"name":"yqiChen","email":"chenyuqi1229@gmail.com","commits":1}]},"readingTime":{"minutes":12.17,"words":3650},"filePathRelative":"posts/后端/springcloud/6_服务保护.md","localizedDate":"2024年6月26日","excerpt":"<!--more--->\\n<h1>服务保护</h1>\\n<h2>一、介绍</h2>\\n<p>在微服务远程调用的过程中，还存在几个问题需要解决。</p>\\n<p>首先是<strong>业务健壮性</strong>问题：</p>\\n<p>例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服 务时，是不是也会异常？从而导致购物车查询失败。但从业务角度来说，为了提升用户体验，即便是商品查询失败，购物车列表也应该正确展示出来，哪怕是不包含最新的商品信息。</p>\\n<p>还有<strong>级联失败</strong>问题：</p>","autoDesc":true}');export{K as comp,$ as data};
